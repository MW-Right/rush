# Rush Hour Solver

This is a puzzle solver and generator for [Rush Hour](https://en.wikipedia.org/wiki/Rush_Hour_(puzzle)).
You may also know this game from one of its iOS implementations, such as [Unblock Me](https://itunes.apple.com/us/app/unblock-me/id315019111?mt=8).

The code is written in [Go](https://golang.org/).

![Examples](https://i.imgur.com/YlT8Y39.png)

### Features

- Can solve puzzles
- Can generate puzzles (such as those shown above)
- Supports arbitrarily-sized boards
- Supports arbitrarily-sized pieces
- Supports "walls" (immovable obstacles)
- Uses "static analysis" to quickly determine if a puzzle cannot be solved without performing a full search
- Can "unsolve" puzzles - given a starting state, find a reachable state that is furthest from the win state
- Can render puzzles to PNG

### Example Puzzle Solution

The solver found a solution to this puzzle in 75 milliseconds. It requires 50 moves (82 steps).

![Example](https://i.imgur.com/eWnPtLo.gif)

### ASCII Format

Puzzles are displayed and can be parsed in a simple ASCII format:

```
BBBCDE
FGGCDE
F.AADE
HHI...
.JI.KK
.JLLMM
```

Empty cells are indicated with a `.`. Walls are indicated with a lowercase `x`. Pieces are indicated with capital letters starting with `A`.

The "primary" piece (the red car) is labeled `A` and must always be horizontal, but can appear on any row. It will always exit to the right. No other horizontal pieces may be on that same row.

### API Example

```go
// define the puzzle in ASCII
desc := []string{
	"BBBCDE",
	"FGGCDE",
	"F.AADE",
	"HHI...",
	".JI.KK",
	".JLLMM",
}

// parse and create a board
board, err := rush.NewBoard(desc)
if err != nil {
	log.Fatal(err)
}

// compute a solution
solution := board.Solve()

// print out solution information
fmt.Printf("solvable: %t\n", solution.Solvable)
fmt.Printf(" # moves: %d\n", solution.NumMoves)
fmt.Printf(" # steps: %d\n", solution.NumSteps)

// print out moves to solve puzzle
for _, move := range solution.Moves {
	fmt.Printf("%s%+d, ", move.Label(), move.Steps)
}
fmt.Println()

// solvable: true
//  # moves: 49
//  # steps: 93
// A-1, C+2, B+1, E+1, F-1, A-1, I-1, K-2, D+2, B+2, G+2, I-2, A+1, H+1,
// F+4, A-1, H-1, I+2, B-2, E-1, G-3, C-1, D-2, I-1, H+4, F-1, J-1, K+2,
// L-2, C+3, I+3, A+2, G+2, F-3, H-2, D+1, B+1, J-3, A-2, H-2, C-2, I-2,
// K-4, C+1, I+1, M-2, D+2, E+3, A+4
```

Run it yourself:

```
go get -u github.com/fogleman/rush
cd ~/go/src/github.com/fogleman/rush
go run cmd/example/main.go
```

### 7x7 Puzzle

Here is an example 7x7 puzzle with walls, generated by the code. The red squares indicate cells that will always be occupied no matter what moves are made, as determined by the static analysis.

![7x7](https://i.imgur.com/uyUyyEW.png)
